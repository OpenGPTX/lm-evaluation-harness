"""
A Corpus and Cloze Evaluation for Deeper Understanding of Commonsense Stories
https://arxiv.org/pdf/1604.01696.pdf

'Story Cloze Test' (2018) is a commonsense reasoning framework for evaluating story
understanding, story generation, and script learning. This test requires a system
to choose the correct ending to a four-sentence story.

Homepage: https://cs.rochester.edu/nlp/rocstories/
"""
import numpy as np
from lm_eval.base import rf, Task
from lm_eval.metrics import mean, fertility


_CITATION = """
@inproceedings{sharma-etal-2018-tackling,
    title = "Tackling the Story Ending Biases in The Story Cloze Test",
    author = "Sharma, Rishi  and
      Allen, James  and
      Bakhshandeh, Omid  and
      Mostafazadeh, Nasrin",
    booktitle = "Proceedings of the 56th Annual Meeting of the Association for Computational Linguistics (Volume 2: Short Papers)",
    month = jul,
    year = "2018",
    address = "Melbourne, Australia",
    publisher = "Association for Computational Linguistics",
    url = "https://aclanthology.org/P18-2119",
    doi = "10.18653/v1/P18-2119",
    pages = "752--757",
    abstract = "The Story Cloze Test (SCT) is a recent framework for evaluating story comprehension and script learning. There have been a variety of models tackling the SCT so far. Although the original goal behind the SCT was to require systems to perform deep language understanding and commonsense reasoning for successful narrative understanding, some recent models could perform significantly better than the initial baselines by leveraging human-authorship biases discovered in the SCT dataset. In order to shed some light on this issue, we have performed various data analysis and analyzed a variety of top performing models presented for this task. Given the statistics we have aggregated, we have designed a new crowdsourcing scheme that creates a new SCT dataset, which overcomes some of the biases. We benchmark a few models on the new dataset and show that the top-performing model on the original SCT dataset fails to keep up its performance. Our findings further signify the importance of benchmarking NLP systems on various evolving test sets.",
}
"""


class StoryCloze(Task):
    VERSION = 0
    DATASET_PATH = "story_cloze"
    DATASET_NAME = None

    def __init__(self, data_dir: str):
        """
        StoryCloze is not publicly available. You must download the data by
        following https://cs.rochester.edu/nlp/rocstories/ and pass the folder
        path into the `data_dir` arg.
        """
        super().__init__(data_dir=data_dir)

    def has_training_docs(self):
        return False

    def has_validation_docs(self):
        return True

    def has_test_docs(self):
        return True

    def training_docs(self):
        pass

    def validation_docs(self):
        return self.dataset["validation"]

    def test_docs(self):
        return self.dataset["test"]

    def doc_to_text(self, doc):
        return " ".join(
            [
                doc["input_sentence_1"],
                doc["input_sentence_2"],
                doc["input_sentence_3"],
                doc["input_sentence_4"],
            ]
        )

    def should_decontaminate(self):
        return True

    def doc_to_decontamination_query(self, doc):
        return " ".join(
            [
                doc["input_sentence_1"],
                doc["input_sentence_2"],
                doc["input_sentence_3"],
                doc["input_sentence_4"],
            ]
        )

    def doc_to_target(self, doc):
        clozes = [doc["sentence_quiz1"], doc["sentence_quiz2"]]
        # `- 1` because the `answer_right_ending` index is 1-based.
        return " " + clozes[doc["answer_right_ending"] - 1]

    def construct_requests(self, doc, ctx):
        """Uses RequestFactory to construct Requests and returns an iterable of
        Requests which will be sent to the LM.

        :param doc:
            The document as returned from training_docs, validation_docs, or test_docs.
        :param ctx: str
            The context string, generated by fewshot_context. This includes the natural
            language description, as well as the few shot examples, and the question
            part of the document for `doc`.
        """
        clozes = [doc["sentence_quiz1"], doc["sentence_quiz2"]]
        requests = [rf.loglikelihood_reqstats(ctx, " {}".format(choice)) for choice in clozes]

        return requests

    def process_results(self, doc, results):
        """Take a single document and the LM results and evaluates, returning a
        dict where keys are the names of submetrics and values are the values of
        the metric for that one document

        :param doc:
            The document as returned from training_docs, validation_docs, or test_docs.
        :param results:
            The results of the requests created in construct_requests.
        """
        lls = [result[0] for result in results]
        reqs_stats = [result[2] for result in results]

        gold = doc["answer_right_ending"] - 1
        pred = np.argmax(lls)
        pred_req_stats = reqs_stats[pred]

        acc = 1.0 if pred == gold else 0.0

        token_ctx_count =  pred_req_stats["tokens_ctx"]
        word_ctx_count =  pred_req_stats["words_ctx"]
        token_cont_count =  pred_req_stats["tokens_cont"]
        word_cont_count =  pred_req_stats["words_cont"]

        return {
            "acc": acc,
            "fertility_ctx": {"tokens": token_ctx_count, "words": word_ctx_count, "include": True},
            "fertility_ctx_pos": {"tokens": token_ctx_count, "words": word_ctx_count, "include": pred == gold},
            "fertility_ctx_neg": {"tokens": token_ctx_count, "words": word_ctx_count, "include": pred != gold},
            "fertility_cont": {"tokens": token_cont_count, "words": word_cont_count, "include": True},
            "fertility_cont_pos": {"tokens": token_cont_count, "words": word_cont_count, "include": pred == gold},
            "fertility_cont_neg": {"tokens": token_cont_count, "words": word_cont_count, "include": pred != gold},
        }

    def aggregation(self):
        """
        :returns: {str: [float] -> float}
            A dictionary where keys are the names of submetrics and values are
            functions that aggregate a list of metrics
        """
        return {
            "acc": mean,
            "fertility_ctx": fertility,
            "fertility_ctx_pos": fertility,
            "fertility_ctx_neg": fertility,
            "fertility_cont": fertility,
            "fertility_cont_pos": fertility,
            "fertility_cont_neg": fertility,
        }

    def higher_is_better(self):
        """
        :returns: {str: bool}
            A dictionary where keys are the names of submetrics and values are
            whether a higher value of the submetric is better
        """
        return {
            "acc": True,
            "fertility_ctx": False,
            "fertility_ctx_pos": False,
            "fertility_ctx_neg": False,
            "fertility_cont": False,
            "fertility_cont_pos": False,
            "fertility_cont_neg": False,
        }


class StoryCloze2016(StoryCloze):
    DATASET_NAME = "2016"


class StoryCloze2018(StoryCloze):
    DATASET_NAME = "2018"
